# coding: utf-8


import plotly.graph_objects as go
import numpy as np
from RecuitSimule import RecuitSimule
from GeneticAlgorithm import GeneticAlgorithm
from Model2Deterministe import Model2Deterministe
from scipy.optimize import minimize, LinearConstraint, linprog
import time


class Model2:
    def __init__(self, parcelle_distrib, years, type_model, forward_year=200, age_cab=52, max_it=2, min_surf=2, max_iter=300000, minimize_coupe_generation=3, save_results=True):
        self.parcelle_distrib = parcelle_distrib
        self.len_gen = age_cab
        self.mean_distrib = np.mean(self.parcelle_distrib)
        self.type_model = type_model
        self.forward_year = forward_year-forward_year % self.len_gen
        self.max_it = max_it
        self.min_surf = min_surf
        self.max_iter = max_iter
        self.minimize_coupe_generation = minimize_coupe_generation
        # list of surfaces
        self.surfaces = self.parcelle_distrib.copy()
        self.years = years
        for i in range(self.forward_year):
            self.surfaces.append(
                self.parcelle_distrib[i % self.len_gen])
            self.years.append(self.years[-1]+1)
        self.modif_surfaces = self.surfaces.copy()
        self.distrib_historic = np.zeros((len(self.modif_surfaces)-self.len_gen, 2*self.max_it+1))
        self.save_results = save_results
        self.savePath = "Result/PlanDeCoupe/" + type_model + "-Result.txt"

        # Genetic algorithm attributs
        self.population = self.surfaces.copy()

    def optimize(self):
        t0 = time.time()
        if self.save_results:
            with open(self.savePath, "w") as f:
                f.write("")
        for generation in range(self.forward_year // self.len_gen):
            print("Generation ", generation, " from ", generation*self.len_gen, " years to ",
                  (generation+1)*self.len_gen-1, " years")
            self.replicate_generation(generation)

            if self.type_model == "Model2-RecuitSimule":
                newX = self.optimize_recuit_simule(generation)
            elif self.type_model == "Model2-Deterministe":
                newX = self.optimize_gen_deterministe(generation)
            elif self.type_model == "Model2-Genetic":
                newX = self.optimize_genetic(generation)
            else:
                print("Wrong input parameter")
                return
            # print("REORGANIZED NEW X : ", self.reorganize_new_gen(newX))

            newXtranspose = np.concatenate((np.zeros((self.len_gen, self.max_it)), np.transpose(
                newX[:, self.max_it: self.len_gen+self.max_it]), np.zeros((self.len_gen, self.max_it))), axis=1)

            for i in range(self.len_gen):
                self.distrib_historic[(generation)*self.len_gen +
                                      i] = newXtranspose[i, i:i+2*self.max_it+1]

            self.create_instructions(newX, generation)

            self.create_new_gen(
                np.sum(newX[:, self.max_it: newX.shape[1]-self.max_it], axis=0), generation)
        print("Optimization time : ", str(int((time.time()-t0)//60)) +
              " minutes " + str(int((time.time()-t0) % 60)) + " secondes")
        return

    def optimize_genetic(self, generation):

        X0 = np.zeros((self.len_gen, self.len_gen+2*self.max_it))
        for j in range(self.len_gen):
            X0[j][j+self.max_it] = self.modif_surfaces[generation*self.len_gen + j]
        print("sum gen X0 : ", np.sum(
            np.sum(X0[:, self.max_it:X0.shape[1]-self.max_it], axis=0)))
        # show initial objective
        initial_loss = self.objective(X0)
        print('Initial SSE Objective: ' +
              str(initial_loss))
        geneticAlgorithm = GeneticAlgorithm(
            X0, nb_gene=3000, nb_elmts=20, min_surf=self.min_surf)

        newX = geneticAlgorithm.run()

        print("gen newX : ", np.round(
            np.sum(newX[:, self.max_it:newX.shape[1]-self.max_it], axis=0), 3))
        print("sum gen newX : ", np.sum(
            np.sum(newX[:, self.max_it:newX.shape[1]-self.max_it], axis=0)))

        print('Final SSE Objective: ' + str(self.objective(newX)))

        return newX

    def objective(self, X):
        if X.shape != (self.len_gen, self.len_gen+2*self.max_it):
            X = self.toX(X)
        return np.var(np.sum(X[:, self.max_it: self.len_gen+self.max_it], axis=0))

    def optimize_gen_deterministe(self, generation):
        model2Deterministe = Model2Deterministe(
            self.modif_surfaces[generation*self.len_gen: (generation+1)*self.len_gen],  max_it=self.max_it)
        newX = model2Deterministe.optimize()
        return newX

    def optimize_recuit_simule(self, generation):

        """
        https://fr.wikipedia.org/wiki/Recuit_simul%C3%A9#Pseudo-code
        http://www.tangentex.com/RecuitSimule.htm
        """
        X0 = np.zeros((self.len_gen, self.len_gen+2*self.max_it))
        for j in range(self.len_gen):
            X0[j][j+self.max_it] = self.modif_surfaces[generation*self.len_gen + j]

        # print("sum gen X0 : ", np.sum(
        #     np.sum(X0[:, self.max_it:X0.shape[1]-self.max_it], axis=0)))
        # show initial objective
        initial_loss = self.objective(X0)
        # print('Initial SSE Objective: ' +
        #       str(initial_loss))
        # optimize
        if generation >= self.minimize_coupe_generation:
            recuitSimule = RecuitSimule(
                X0, generation, max_iter=self.max_iter, max_it=self.max_it, minimize_coupe=True, min_surf=self.min_surf)
        else:
            recuitSimule = RecuitSimule(
                X0, generation, max_iter=self.max_iter, max_it=self.max_it, minimize_coupe=False, min_surf=self.min_surf)

        newX = recuitSimule.optimize()

        # print("gen newX : ", np.round(
        #     np.sum(newX[:, self.max_it:newX.shape[1]-self.max_it], axis=0), 3))
        # print("sum gen newX : ", np.sum(
        #     np.sum(newX[:, self.max_it:newX.shape[1]-self.max_it], axis=0)))

        print('Loss (variance) generation ' + str(generation) +
              " : " + str(np.round(self.objective(newX), 3)))

        return newX

    def reorganize_new_gen(self, newX):
        newX_optimized = newX.copy()
        # pour chaque ligne de la matrice, on regarde si des décalages ont été
        # prévu pour cette année, si c'est le cas et que
        # des déplacements d'autres années ont également étéé prévu, on intervetit
        # les déplacement afin de limiter au maximum les reprogrammations
        for i in range(newX.shape[0]):
            qtn_deplacee_anneei = 0
            qtn_deplacee_autre_annnee = 0
            for j in range(i+self.max_it+1, i+2*self.max_it+1):
                qtn_deplacee_anneei += newX[i, j]
                qtn_deplacee_autre_annnee += newX[j-self.max_it, i+self.max_it]
            if qtn_deplacee_anneei > qtn_deplacee_autre_annnee:
                for j in range(i+self.max_it+1, i+2*self.max_it+1):
                    pass
                    # newX[j-self.max_it, i+self.max_it] = 0
                    # newX[i, j]
                    # qtn_deplacee_autre_annnee -=

        return newX_optimized

    def create_new_gen(self, M, generation):

        for i in range((generation+1)*self.len_gen, (generation+2)*self.len_gen):
            self.modif_surfaces[i] = M[i-(generation+1)*self.len_gen]
        return

    def replicate_generation(self, generation):
        for i in range((generation+1)*self.len_gen, (generation+2)*self.len_gen):
            self.modif_surfaces[i] = self.modif_surfaces[i -
                                                         self.len_gen]
        return

    def plot_surfaces(self, surf, name="demo", title="Title"):
        fig = go.Figure()
        fig.add_trace(go.Bar(x=self.years, y=surf,
                             marker_line_width=1.5, width=1, name='Distribution'))
        fig.add_trace(go.Scatter(x=self.years[:len(surf)-self.len_gen], y=[np.var(
            surf[k:k+self.len_gen]) for k in range(len(surf)-self.len_gen)], name='Variance'))
        fig.add_trace(go.Scatter(x=self.years, y=[
                      self.mean_distrib for k in surf], name='Objectif'))
        fig.update_layout(title=title)
        fig.write_html(name + ".html")
        return

    def plot_distribution_surfaces(self, surf, name="demo", title="Title"):
        fig = go.Figure()
        for i in range(surf.shape[1]):
            fig.add_trace(go.Bar(x=self.years[self.len_gen:], y=surf[:, i],
                                 marker_line_width=1.5, width=1, name='Age de coupe : '+str(self.len_gen+self.max_it-i)))
        fig.update_layout(barmode='stack')
        fig.update_layout(title=title)
        fig.write_html(name + ".html")
        return

    def create_instructions(self, newX, generation):
        text = ""
        newXtranspose = np.concatenate((np.zeros((self.len_gen, self.max_it)), np.transpose(
            newX[:, self.max_it: self.len_gen+self.max_it]), np.zeros((self.len_gen, self.max_it))), axis=1)
        for i in range(self.len_gen):
            toCut = np.round(newXtranspose[i, i:i+2*self.max_it+1], 5)
            # c'est la transposer qui donne ce qu'il faut couper l'année i
            text += "A l'année " + str(self.years[generation*self.len_gen+i]+self.len_gen) + " on coupe " + str(
                np.sum(toCut)) + " hectares en tout, il faut couper "
            for j in range(2*self.max_it):
                # print(j, self.max_it)
                text += str(toCut[j]) + " hectares de " + \
                    str(self.len_gen+j-self.max_it) + " ans, "
            text += str(toCut[-1]) + " hectares de " + \
                str(self.len_gen+self.max_it) + " ans. \n"
        if self.save_results:
            with open(self.savePath, "a") as f:
                f.write(text)
        return
