import numpy as np
import copy
import random


class GeneticAlgorithm:
    def __init__(self, X0, nb_gene=10, nb_elmts=10, max_it=2, min_surf=0.5):
        self.X0 = X0
        self.X = X0.copy()
        self.max_it = max_it
        self.len_X = X0.shape[0]
        self.nb_generation = nb_gene
        self.nb_elements = nb_elmts
        self.len_vect_X = (1 + 2 * self.max_it) * self.len_X
        self.pop = np.zeros((self.len_vect_X, self.nb_elements))
        self.fitness = [-np.inf] * self.nb_elements
        self.num_parents = self.nb_elements // 2
        self.random_size = self.nb_elements - self.num_parents
        self.values_lines = np.sum(self.X0, axis=1)
        self.min_surf = min_surf

    
    def vectorize_X(self, X):
        vect_X = []
        for i in range(self.len_X):
            vect_X += list(X[i, i:i + 2 * self.max_it +1])
        return vect_X
    
    def matrify_vect_X(self, vect_X):
        X = np.zeros((self.len_X, self.len_X))
        X = np.concatenate((np.zeros((self.len_X,2)), X), axis=1)
        X = np.concatenate((X, np.zeros((self.len_X,2))), axis=1)
        n = self.len_X
        for i in range(n):
            k =  (2 * self.max_it + 1) * i
            
            X[i,i : i + 2 * self.max_it + 1] = vect_X[k : k + 2 * self.max_it + 1]
        return X
        

    def initialize_pop(self):
        for i in range(self.nb_elements):
            self.pop[:,i] = self.vectorize_X(self.X0)


    def select_mating_pool(self):

    # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.

        parents = [np.nan] * self.num_parents
        for parent_num in range(self.num_parents):

            min_fitness_idx = np.where(self.fitness == np.min(self.fitness))

            min_fitness_idx = min_fitness_idx[0][0]

            parents[parent_num] = self.pop[:, min_fitness_idx]

            self.fitness[min_fitness_idx] = np.inf

        return parents


    def crossover(self, parents):
        offspring = np.zeros((self.len_vect_X, self.len_X))

        crossover_possibilities = np.linspace(5, 45, 5)
        # The point at which crossover takes place between two parents. Usually, it is at the center.
        crossover_point = int(random.choices(crossover_possibilities)[0])
        offspring[:,0] = parents[0]
 
        for k in range(1, self.num_parents):
            # Index of the first parent to mate.
            parent1_idx = random.randint(0, self.num_parents - 1)
            # Index of the second parent to mate.
            parent2_idx = random.randint(0, self.num_parents - 1)
            # The new offspring will have its first half of its genes taken from the first parent.
            offspring[:crossover_point, k] = parents[parent1_idx][:crossover_point]
            # The new offspring will have its second half of its genes taken from the second parent.
            offspring[crossover_point:, k] = parents[parent2_idx][crossover_point:]
        return offspring


    def mutation(self, offspring_crossover):

        # Mutation changes a single gene in each offspring randomly.

        for idx in range(1, self.num_parents):

            # The random value to be added to the gene.

            gene = random.randint(0, self.len_vect_X - 1)

            seg_length = 2 * self.max_it + 1

            idx_seg = gene // seg_length

            random_value = np.random.uniform(0, 1.0, 1)

            has_to_balance = True

            for i in range(idx_seg * seg_length, (idx_seg + 1) * seg_length ):
                if i != gene and offspring_crossover[i, idx] >= random_value and has_to_balance:
                    offspring_crossover[i, idx] -=  random_value
                    offspring_crossover[gene, idx] +=  random_value
                    has_to_balance = False

        return offspring_crossover

    def generate_distrib(self, value_sum, length=5):
        distrib = [random.uniform(0, 1)]
        for i in range(1, length-1):
            srf_aleatoire = random.uniform(0, 1-sum(distrib[:i]))
            if (srf_aleatoire > self.min_surf):
                distrib.append(srf_aleatoire)
            else:
                distrib.append(0)
        if 1-sum(distrib) < self.min_surf:
            # if distrib[self.max_it] != 0:
            #     distrib[self.max_it] += 1-sum(distrib)
            # else:
            for j in range(len(distrib)):
                if distrib[j] != 0:
                    distrib[j] += 1-sum(distrib)
                    break
            if sum(distrib) == 0:
                distrib.append(1-sum(distrib))
            else:
                distrib.append(0)
        else:
            distrib.append(1-sum(distrib))
        random.shuffle(distrib)
        return value_sum*np.array(distrib)

    def add_random_individuals(self, offspring_crossover):
            seg_length = 2 * self.max_it + 1

            random_individuals = np.zeros((self.len_vect_X, self.random_size))
            for j in range(self.random_size):
                for i in range(self.len_vect_X // seg_length):
                    k = i * seg_length
                    random_individuals[k:k + seg_length,j] = self.generate_distrib(self.values_lines[i],length=2*self.max_it+1)
            
            offspring_crossover[:, self.num_parents:self.nb_elements] = random_individuals
            return offspring_crossover

    def score_calculation(self, X):
        return np.var(np.sum(X[:, self.max_it:X.shape[1]+self.max_it], axis=0))

    def run(self):

        # Population initialization

        self.initialize_pop()

        for _ in range(self.nb_generation):

            # Score calculation

            for i in range(self.nb_elements):
                self.fitness[i] = self.score_calculation(self.matrify_vect_X(self.pop[:,i]))
            
            # Mating selection

            parents = self.select_mating_pool()

            # Crossover

            offspring = self.crossover(parents)

            # Mutations

            mutate = self.mutation(offspring)


            # Random

            final = self.add_random_individuals(mutate)
            self.pop = final

            score = self.score_calculation(self.matrify_vect_X(final[:, 0]))

            # print(self.matrify_vect_X(final[:, 0]))

        return self.matrify_vect_X(final[:, 0])
