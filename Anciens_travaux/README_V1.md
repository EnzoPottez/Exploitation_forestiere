# ProjetOptionInformatique

Ce dépôt contient le travail réalisé par les étudiants de l'Ecole Centrale de Lyon :

- Baptiste Desarnauts
- Théo Malka-Lacombe
- Maxime Peter
- Julien Verdun

dans le cadre de leur projet d'option informatique commandité par la société Kiriola, représenté par M. Charles De Rambuteau.

Le projet concerne l'**optimisation d'une exploitation forestière**.

Les étudiants ont travaillé sur les sujets techniques en collaboration avec deux enseignants/chercheurs à l'ECL, M. Stéphane Derrode et M. Alexandre Saidi.

## Installation

Créer un environnement virtuel via un terminal :

```
python -m venv venv
```

Activer l'environnement virtuel :

```
./venv/Scripts/activate
```

Se déplacer dans le dossier root du projet :

```
cd /CheminVersLeDossierDuProjet
par exemple : cd /Users/Jean/Desktop/ProjetOptionInformatique
```

Dans le dossier root du projet exécuter :

```
pip install -e .
```

Installer toutes les librairies et les dépendances :

```
pip install -r requirements.txt
```

## Traitement des données

Les données utilisées pour l'optimisation sont stockées dans le fichier `Data/simu.json`.

Elles sont traitées et mises en forme avec le fichier `DataProcessing/DataProcessing.py` qui crée un dictionnaire contenant pour chaque année, les surfaces d'arbres arrivant à âge de coupe à blanc.

Les algorithmes et modèles ci-dessous fonctionnent avec un fichier ayant la même structure que le fichier json. Il est donc possible de le remplacer par un fichier similaire et les algorithmes fonctionneront toujours. Dans le cas où la structure du fichier changerait, il faudrait modifier les méthodes de la classe **DataProcessing** et les adapter aux nouvelles données.

## Modèle 1

Le modèle 1 n'a pas pu être implémenté. Vous trouverez plus de détail concernant les problèmes rencontrés sur ce modèle sur le rapport de projet.

## Modèle 2

Le modèle 2 est décrit de façon mathématique dans le document `modelisations.pdf`. Une brève description en est donnée ci-dessous puis ce document explique comment lancer et choisir les paramètres du modèle.

### Principe du modèle

Le modèle 2 optimise la distribution des surfaces par année de génération en génération.

Il utilise la distribution initiale des surfaces arrivant à âge de coupe à blanc par année, et calcule les opérations de décalage à effectuer sur la prochaine génération afin d'en minimiser la variance.

Le modèle s'intéresse à une génération complète et est donc efficace pour rapidement absorber les pics.

Pour modéliser le problème, on stocke dans une matrice $X$ de taille ($forward year$ x $forward year + 2 * max it$) avec :

- $forward year$ le nombre d'années sur lesquelles l'optimisation aura lieu (une génération)
- $maxit$ le nombre d'années sur lesquelles la coupe peut-être décallée

C'est une matrice creuse et initialement diagonale qui represente les volumes à couper pour chaque année.

L'objectif sera de minimiser la variance des colonnes (homogénéïté des coupes) tout en concervant la somme par ligne (conservation des volumes). Pour ce faire on utilise les méthodes de résolution suivantes.

### Les méthodes de résolution

**Algorithme déterministe**

Une méthode déterministe n'a pas pu être implémenté pour ce modèle, le trop grand nombre de contraintes ne permettaient pas aux différents solveurs d'en donner une solution exacte. En effet, les solveurs préfèrent minimiser la fonction objectif au dépis des contraintes.

**Algorithme par recuit simulé**

En algorithmique, le recuit simulé est une méthode de programmation empirique (métaheuristique) inspirée d'un processus utilisé en métallurgie. On alterne dans cette dernière des cycles de refroidissement lent et de réchauffage (recuit) qui ont pour effet de minimiser l'énergie du matériau. Cette méthode est transposée en optimisation pour trouver les extrema d'une fonction.

Cette méthode donne une solution approchée à notre problème d'optimisation.

**Algorithme génétique**

Les algorithmes génétiques appartiennent à la famille des algorithmes évolutionnistes. Leur but est d'obtenir une solution approchée à un problème d'optimisation, lorsqu'il n'existe pas de méthode exacte (ou que la solution est inconnue) pour le résoudre en un temps raisonnable. Les algorithmes génétiques utilisent la notion de sélection naturelle et l'appliquent à une population de solutions potentielles au problème donné. La solution est approchée par « bonds » successifs, comme dans une procédure de séparation et évaluation (branch & bound), à ceci près que ce sont des formules qui sont recherchées et non plus directement des valeurs.

Dans notre cas, l'algorithme génétique les paramètres à optimiser sont les poids du plan de coupe. Ces poids sont stockés dans la matrice $X$ présentée plus haut. Cette matrice est initialement diagonale (aucunes coupes n'est décalée). On calcule la variance globale de cette matrice pour obtenir notre point de départ. On initialise une population de $k$ matrices. On conserve la matrice ayant le meilleur score à chaque passage dans l'algorithme mais on modifier le reste des matrices soit en leur appliquant des croisements et des mutations, soit en les remplaçant par de nouvelles matrices aléatoire. On calcule les nouveaux score et on classe les meilleurs individus. On réitère le processus jusqu'à convergence du score vers un minimum.

### Exécution du modèle 2

Le modèle 2 peut être exécuter via la ligne de commande paramétrée suivante.

```
python .\Models\mainModel2.py [-h] [--forward_year FORWARD_YEAR] [--model MODEL] [--max_it MAX_IT] [--min_surf MIN_SURF] [--max_iter MAX_ITER]
 [--minimize_coupe_generation MINIMIZE_COUPE_GENERATION]
```

Les paramètres possèdent des valeurs par défaut (voir aide ci-dessous) mais ces valeurs sont modifiables lors de l'optimisation.

Aide du modèle 2 :

```
optional arguments:
  -h, --help            show this help message and exit
  --forward_year FORWARD_YEAR, -fy FORWARD_YEAR
                        modifie le nombre d'année sur lequel lancer
                        l'optimisation, par défaut 400 years
  --model MODEL, -m MODEL
                        modifie le solveur du modèle (0 pour le recuit simulé,
                        1 pour la manière déterministe ou 2 pour l'algorithme
                        génétique), par défaut 0
  --max_it MAX_IT, -it MAX_IT
                        modifie l'intervalle maximal de décalage de la coupe à
                        blanc, en année, par défaut 2 years
  --min_surf MIN_SURF, -ms MIN_SURF
                        modifie la surface minimale de coupe autorisé, en
                        hectare, par défaut 0.01 hectares
  --max_iter MAX_ITER, -iter MAX_ITER
                        modifie le nombre d'itérations maximal pour
                        l'algorithme de recuit simulé, par défaut n300000
  --minimize_coupe_generation MINIMIZE_COUPE_GENERATION, -mcg MINIMIZE_COUPE_GENERATION
                        Generation à partir de laquel limiter les décalages,
                        par défaut 5
  --save_results SAVE_RESULTS, -sr SAVE_RESULTS
                        Active ou non (True ou False) l'écriture des résultats
                        de l'optimisation dans le dossier Result/PlanDeCoupe,
                        activé par défaut
```

Voici un exemple de ligne de commande permettant d'exécuter le modèle 2 avec des paramètres par défaut.

```
python .\Models\mainModel2.py --forward_year 400 --model 0 --max_it 2 --min_surf 0.01 --max_iter 300000 --minimize_coupe_generation 5
```

Le modèle 2 calcule la distribution des surfaces sur plusieurs générations, selon le paramètre **forward_year** correspondant au nombre d'année sur lequel l'optimisation est réalisée. Il est possible de choisir le solveur utilisé **model** (par défaut le recuit simulé). Puis le modèle calcule les déplacements de coupe à blanc à effectuer pour minimiser le plus rapidement possible la variance des surfaces (lissage du modèle).
Il est possible d'imposer au modèle une surface minimale de décalage de **min_surf** hectares, afin de ne pas avancer ou retarder de trop petites surfaces. L'intervalle maximale de décale est défini par l'attribut **max_it** en années (un intervalle de 2 ans correspond à une possibilité de décalage à +- 2 ans de l'âge de coupe à blanc).

Le modèle 2 intègre l'attribut **minimize_coupe_generation** qui définit la génération (une génération correspond à une cinquantaine d'année)à partir de laquelle intégrer à la fonction de coût du modèle, fonction à minimiser, la variance de la répartition par année des décalages, afin de limiter à long terme les opérations de décalage.

Les différents attributs ont bien sur un impact sur les performances du modèle.

Le modèle génère plusieurs fichiers dans le dossier `Result` du projet :

- un fichier json `Result/HistoricDecoupe/Model2-{model}-Result.json` qui contient pour chaque année, les décalages de surface à réaliser
- un fichier html `Result/Model2-{model}/Model2-{model}.html` qui contient un graphique avec la distribution des surfaces optimisées (surface à couper par année) ainsi qu'une courbe de la variance au cours du temps
- un fichier html `Result/Model2-{model}/Model2-{model}-distrib.html` qui contient un graphique avec la distribution des surfaces optimisées, découpée par âge de coupe à blanc nominal des surfaces
- un fichier texte `Result/PlanDeCoupe/Model2-{model}-Result.txt` contenant les instructions de coupe surfaciques.

## Modèle 3

Le modèle 3 est décrit de façon mathématique dans le document `modelisations.pdf`. Une brève explication est aussi donnée sur la résolution numérique.

### Méthode de résolution

La résolution se faire de façon incrémentale (année par année). C'est à dire que chaque année on calcule la quantité d'arbres à couper et donc la quantité à replanter l'année suivante. La résolution se fait via le module minimize de scipy qui permet de minimiser la fonction objectif. Ce modèle prends plusieurs paramètres en entrée que l'on peut faire varier lors de l'éxécution.

### Exécution du modèle 3

La commande pour lancer le modèle 3 est :

```
python .\Models\mainModel3.py [-h] [--simulation SIMULATION] [--delta DELTA] [--option] [--min_surface MIN_SURFACE]
exemple:
python .\Models\mainModel3.py --simulation 400 --delta 2 --min_surface 0.01 --age_cab 52

Modèle 3 avec la nouvelle fonction de minimisation
python .\Models\mainModel3_bis.py --simulation 400 --delta 2 --min_surface 0.01 --age_cab 52

Model3 avec modification de la valeur du pic:
python .\Models\mainModel3Pic.py --simulation 400 --delta 2 --min_surface 0.01 --age_cab 52
```

Les paramètres possèdent des valeurs par défaut (voir aide ci-dessous) mais ces valeurs sont modifiables lors de l'optimisation.

Aide du modèle 3 :

```
optional arguments:
  -h, --help            show this help message and exit
  --simulation SIMULATION
                        Durée en année de la simulation
  --delta DELTA         Définie l'intervale d'age de coupe à 50 ans + ou -
                        delta
  --option              Active l'option permettant de replanter avec un délais
                        de 1 année si nécessaire
  --min_surface MIN_SURFACE
                        Définie la surface minimale de coupe
  --saveresults SAVERESULTS
                        Active ou non l'écriture des résultats de
                        l'optimisation dans le dossier Result/PlanDeCoupe
```

Le paramètre **simulation** permet de régler la durée de la simulation. Il est par défaut à 400 ans.<br>
Le paramètre **delta** permet de régler l'interval pendant lequel il est possible de couper les arbres à blanc.<br>
Le paramètre **option** permet d'activer ou non le décalage d'un an de la plantation si nécessaire. Cet argument ne requiert pas de valeur. En effet, pour l'utiliser il suffit de rajouter `--option`.<br>
Le paramètre **min_surface** permet de définir une surface minimale de coupe en hectars. Pour l'instant celle-ci est de 0.1 hectars par défaut. **/!\Attention cette option est en cours de développement/**

Le modèle génère un fichier de plan de coupe dans le dossier `Result/PlanDeCoupe`. Ce fichier se nomme automatiquement `resultModel3.txt`. Il permet d'afficher année par année la quantité d'arbres à couper en fonction de leur âge.
Le lancement du modèle génère aussi un graphique qui s'affiche automatiquement dans le navigateur par défaut de l'utilisateur. Ce graphique peut ensuite être sauvegardé.

## Combinaison des modèles

Le modèle 2 est efficace sur les premières générations puis a du mal à converger. Le modèle 3 est peu efficace pour l'absorbtion des grands pics mais plus efficace à long terme.

On combine les deux modèles pour profiter des avantages de chacun et limiter leurs inconvénients.

On exécute la combinaison des modèles via la ligne de commande suivante.

```
./Models/ModelsCombination.py [-h] [--forward_year FORWARD_YEAR]
                            [--start_year START_YEAR] [--age_cab AGE_CAB]
                            [--model MODEL] [--max_it MAX_IT]
                            [--min_surf MIN_SURF] [--max_iter MAX_ITER]
                            [--minimize_coupe_generation MINIMIZE_COUPE_GENERATION]

python ./Models/ModelsCombination.py --forward_year 400 --start_year 2021 --age_cab 52 --model 0 --max_it 2 --min_surf 0.01 --model2_time 110

Combination Serie:
  -Avec fréquence
python ./Models/ModelsCombinationSerie.py --forward_year 400 --start_year 2021 --age_cab 52 --model 0 --max_it 2 --min_surf 0.01 --frequence 20
  -Avec test MinMax
python ./Models/ModelsCombinationSerie.py --forward_year 400 --start_year 2021 --age_cab 52 --model 0 --max_it 2 --min_surf 0.01 --test_min_max True

ModelCombination avec modification de la valeur du pic:
python ./Models/ModelsCombinationPic.py --forward_year 400 --start_year 2021 --age_cab 52 --model 0 --max_it 2 --min_surf 0.01

optional arguments:
  -h, --help            show this help message and exit
  --forward_year FORWARD_YEAR, -fy FORWARD_YEAR
                        modifie le nombre d'année sur lequel lancer
                        l'optimisation, par défaut 400 années
  --model2_time MODEL2_TIME, -mt MODEL2_TIME
                        modifie le nombre d'année sur lequel lancer
                        l'optimisation avec le modèle 2, par défaut 110 années
  --start_year START_YEAR, -sy START_YEAR
                        modifie l'année de départ du lancement de
                        l'optimisation, par défaut 2021
  --age_cab AGE_CAB, -ac AGE_CAB
                        modifie l'age de coupe à blanc, par défaut 52 années
  --model MODEL, -m MODEL
                        modifie le solveur du modèle (0 pour le recuit simulé,
                        1 pour la manière déterministe ou 2 pour l'algorithme
                        génétique), par défaut 0
  --max_it MAX_IT, -it MAX_IT
                        modifie l'intervalle maximal de décalage de la coupe à
                        blanc, en année, par défaut 2 années
  --min_surf MIN_SURF, -ms MIN_SURF
                        modifie la surface minimale de coupe autorisé, en
                        hectare, par défaut 0.01 hectares
  --max_iter MAX_ITER, -iter MAX_ITER
                        modifie le nombre d'itérations maximal pour
                        l'algorithme de recuit simulé, par défaut 400000
  --minimize_coupe_generation MINIMIZE_COUPE_GENERATION, -mcg MINIMIZE_COUPE_GENERATION
                        Generation à partir de laquel limiter les décalages,
                        par défaut 5
```

Le modèle génère plusieurs fichiers dans le dossier `Result` du projet :

- un fichier html `Result/ModelsCombination/modelsCombination.html` qui contient un graphique avec la distribution des surfaces optimisées (surface à couper par année) ainsi qu'une courbe de la variance au cours du temps
- un fichier html `Result/ModelsCombination/ModelCombination-distrib.html` qui contient un graphique avec la distribution des surfaces optimisées, découpée par âge de coupe à blanc nominal des surfaces
- un fichier json `Result/HistoricDecoupe/ModelsCombination-Result.json` qui contient pour chaque année, les décalages de surface à réaliser
- un fichier texte `Result/PlanDeCoupe/ModelsCombination-Result.txt` contenant les instructions de coupe surfaciques.

## Comparaison des modèles

Le script python `Result/ModelComparison/modelComparison.py` permet de générer le fichier html `Result/ModelComparison/modelComparison.html`. Il superpose pour chacun des modèles les distributions des surfaces par années ainsi que les courbes de variance.

Il permet donc de comparer les résultats pour le modèle 3, le modèle 2 (avec les 2 méthodes de recuit simulé et algorithme génétique), la combinaison des modèles 2 et 3.

L'exécution de cet algorithme est réalisé par la ligne de commande suivante. Il est possible de modifier l'âge de coupe à blanc nominal (fixé à 52 ans par défaut) et les modèles à représenter (par défaut les modèles cités plus haut).

Les optimisations ne sont pas relancées pour chacun des modèles. L'algorithme utilise les fichiers textes contenant les résultats des optimisations stockés dans le dossier `./Result/ModelComparison`. Ainsi, si on souhaite avoir des paramètres spécifiques pour un modèle, il convient d'exécuter ce modèle avec les paramètres souhaités, le résultat de l'optimisation sera alors enregistré dans le fichier texte correspondant et on pourra alors lancer la comparaison des modèles comme suit :

```
python .\Result\ModelComparison\modelComparison.py [-h] [--age_cab AGE_CAB] [--models MODELS]


optional arguments:
  -h, --help            show this help message and exit
  --age_cab AGE_CAB, -ac AGE_CAB
                        modifie l'age de coupe à blanc, par défaut 52 années
  --start_year START_YEAR, -sy START_YEAR
                        modifie l'année de départ du lancement de
                        l'optimisation, par défaut 2021
  --models MODELS, -mo MODELS
                        modifie les modèles à comparer, par défaut
                        Model2-RecuitSimule, Model2-Genetic, Model3,
                        ModelsCombination. Veillez à renseigner les modèles en
                        les séparant par une virgule ','
```

La comparaison des modèles génère le fichier html `./Result/ModelComparison/modelComparison.html` qu'il est possible d'ouvrir dans un navigateur web.

## Plan de coupe

Le script `plan de coupe/Plan de coupe v2.ipynb` est le notebook qui permet de générer 50 années du plan de coupe. Plus de détails quand à son implémentation et aux limitations de cet algorithme sont disponibles sur le rapport `modelisations.pdf`.

Cet algorithme prend 2 sources de données : `Data/simu.json` (ce sont les données de l'exploitation) et `Result/HistoricDecoupe/ModelsCombination-Result.json`, ou les résultats d'un autre modèle si besoin (ce sont les résultats du modèle choisi). Il faut faire attention à ce que ces deux chemins soient bien spécifiés dans le notebook.

Les sorties sont le plan de coupe en sortie `resultat_plan_coupe.json` ainsi que les logs d'éxecution `logs_plan_de_coupe.txt` qui permettent une lecture plus détaillée de l'exécution.
