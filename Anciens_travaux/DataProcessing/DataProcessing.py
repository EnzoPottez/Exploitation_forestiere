import json
import numpy as np


class DataProcessing:
    def __init__(self, age_cab=52, delta=0, path="simu.json"):
        self.age_cab = age_cab
        self.delta = delta
        self.max_year = 2021-age_cab-delta
        
        with open(path) as json_file:
            self.data = json.load(json_file)
        self.parcelles_cp = self.comput_parcelles_cp()
        self.years = self.comput_year()
        self.parcelles_cpt = self.comput_parcelles_cpt()


    def comput_parcelles_cp(self):
        parcelles_cp = {}
        for index_category in range(len(self.data["categoriePeuplements"])):
            cpi = self.data["categoriePeuplements"][index_category]["parcelleForestieres"]

            parcelles_cpi = {}
            for parcelle in cpi:
                if parcelle["annee"] in parcelles_cpi:
                    parcelles_cpi[parcelle["annee"]] += parcelle["surface"]
                else:
                    parcelles_cpi[parcelle["annee"]] = parcelle["surface"]

            if len(parcelles_cpi.keys()) > 2:
                parcelles_cp[self.data["categoriePeuplements"][index_category]
                             ["categoriePeuplement"]["id"]] = parcelles_cpi
                
        return parcelles_cp

    def comput_year(self):
        min_year = min([int(year)
                        for year in self.parcelles_cp[list(self.parcelles_cp.keys())[0]].keys()])
        max_year = max([int(year)
                        for year in self.parcelles_cp[list(self.parcelles_cp.keys())[0]].keys()])

        return [year for year in range(min_year, max_year+1)]

    def comput_parcelles_cpt(self):
        parcelles_cpt = {}
        for cpi in self.parcelles_cp:
            parcelles_cpt[cpi] = []
            for year in self.years:
                if str(year) not in self.parcelles_cp[cpi].keys():
                    parcelles_cpt[cpi].append(0)
                else:
                    parcelles_cpt[cpi].append(
                        self.parcelles_cp[cpi][str(year)])
                    
        return parcelles_cpt[2][-(self.age_cab+self.delta):]
    
    def parcelles_ancien_pic(self):
        print('coucou')
        parcelles_ancien_intervention_prevue = {}
        parcelles_ancien_intervention_non_prevue = {}
        
        for index_category in range(len(self.data["categoriePeuplements"])):
            if self.data["categoriePeuplements"][index_category]["categoriePeuplement"]["id"] == 2: 
                #on va chercher les douglas
                cpi = self.data["categoriePeuplements"][index_category]["parcelleForestieres"]
     
                for parcelles in cpi:
                
                    if int(parcelles["annee"]) < self.max_year:  
                        #on prend les arbres anciens
                        
                        compteur = 0
                        if parcelles["intervention"]!=[]:
                            #on teste si il y a une intervention prévue
                            for i in range(len(parcelles["intervention"])):
                                if parcelles["intervention"][i]["operation"] == 14:
                            #on teste si l'intervention prévue est une coupe à blanc
                        
                                    parcelles_ancien_intervention_prevue[parcelles["id"]] = [parcelles["annee"],int(parcelles["intervention"][i]["anneeProgrammationEffective"]),parcelles["surface"]]
                                
                                    compteur = 1
                                
                        if compteur == 0:
                            # dans le cas où il n'y as pas de coupe à blanc prévue
                            parcelles_ancien_intervention_non_prevue[parcelles["id"]] = [parcelles["annee"],parcelles["surface"]]
        
        
        
            data = self.parcelles_cpt
            
            for i in parcelles_ancien_intervention_prevue:
                # on ajoute la surface de la parcelle à son année de plantation fictive
                indice = parcelles_ancien_intervention_prevue[i][1] -2021 - self.age_cab
    
                data[indice]+= parcelles_ancien_intervention_prevue[i][2]
    
            for i in parcelles_ancien_intervention_non_prevue:
                # on ajoute la surface de la parcelle à la première année
                indice = -self.age_cab
    
                data[indice]+= parcelles_ancien_intervention_non_prevue[i][1]
            
            return data

    
    def parcelles_ancien_optimise1(self):
        
        # stratégie d'optimisation initiale numéro 1: on remplit les 'trous'
        # (valeur de l'année<moy) avec les arbres anciens, et tant qu'on n'a pas dépassé la moyenne
        # Une fois qu'on a dépassé la moyenne, on avance jusqu'au prochain trou
        # On ne se fixe pas d'année de décalage maximum.
        
        parcelles_ancien_intervention = {}

        
        for index_category in range(len(self.data["categoriePeuplements"])):
            if self.data["categoriePeuplements"][index_category]["categoriePeuplement"]["id"] == 2: 
                #on va chercher les douglas
                cpi = self.data["categoriePeuplements"][index_category]["parcelleForestieres"]
     
                for parcelles in cpi:
                
                    if int(parcelles["annee"]) < self.max_year:  
                        #on prend les arbres anciens
                        
                            parcelles_ancien_intervention[parcelles["id"]] = [parcelles["annee"],parcelles["surface"]]
        
        data = self.parcelles_cpt
     
        
        count = 0

        for i in parcelles_ancien_intervention:

            count += parcelles_ancien_intervention[i][1]
            
        moy = (np.sum(data)+ count)/self.age_cab  #moyenne des données avec les arbres anciens inclus
        
        sort_parcelles_ancien = sorted(parcelles_ancien_intervention.items(), key=lambda x: x[1][0])
        # on trie les arbres anciens par année croissante

        i = 0
        year = 0

        while i < len(sort_parcelles_ancien) :
            while data[year] < moy:
                # tant que la valeur est inférieure à la moyenne visée, on remplit le trou
                data[year] += sort_parcelles_ancien[i][1][1]
                i=i+1  #on passe à la parcelle ancienne suivante
                
            year = year + 1  #on passe à l'année suivante
            
        return(data)
            
    def parcelles_ancien_optimise2(self,limit_decal):
        
        # stratégie d'optimisation initiale numéro 2: on cherche l'année de valeur minimale 
        # dans la portée de limit_decal, et on y ajoute la parcelle la plus grande.
        # On recommence l'opération jusqu'à ce qu'on aie placé tous les arbres anciens
       
        parcelles_ancien_intervention = {}

        
        for index_category in range(len(self.data["categoriePeuplements"])):
            if self.data["categoriePeuplements"][index_category]["categoriePeuplement"]["id"] == 2: 
                #on va chercher les douglas
                cpi = self.data["categoriePeuplements"][index_category]["parcelleForestieres"]
     
                for parcelles in cpi:
                
                    if int(parcelles["annee"]) < self.max_year:  
                        #on prend les arbres anciens
                        
                            parcelles_ancien_intervention[parcelles["id"]] = [parcelles["annee"],parcelles["surface"]]
        
        data = self.parcelles_cpt
            
        sort_parcelles_ancien = sorted(parcelles_ancien_intervention.items(), key=lambda x: x[1][1], reverse=True)
        # on trie les arbres anciens par surface décroissante
 
        i = 0           
        while i < len(sort_parcelles_ancien) :
                
                imin = data.index(min(data[:limit_decal]))
                # on cherche l'année de valeur minmale, et on ajoute la plus grosse parcelle
                data[imin] += sort_parcelles_ancien[i][1][1]
                i=i+1  #on passe à la parcelle ancienne suivante
                        
        return(data)

        
        
        