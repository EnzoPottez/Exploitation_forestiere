import numpy as np
import os
from cvxopt import matrix, solvers
import plotly.graph_objects as go
from plotly.subplots import make_subplots

class Model3():

    def __init__(self, data, simulationTime, delta=2, age_cab=52, plantOption=False, min_surface=0.1, saveResults=True, model_combination=0, mean_entree=0):

        self.data = data
        self.simulationTime = simulationTime
        self.plantOption = plantOption
        if model_combination == 0:
            self.mean = np.sum(self.data)/age_cab   # on utilise le modèle 3 seul
        else:
            self.mean = mean_entree        # on utilise le modèle 3 dans le modèle combination
        self.max = np.max(self.data)
        self.delta = delta
        self.age_cab=age_cab
        self.min_surface = min_surface
        self.saveResults = saveResults
        self.savePath = "CVXOPT/resultats/Model3.txt"
        self.cuttingRange = list(range(self.age_cab-self.delta, self.age_cab+self.delta+1))
        self.plantDelay = 0

        if self.saveResults and os.path.exists(self.savePath):
            os.remove(self.savePath)
        self.result = []
        self.distrib_historic = []

    def moveElement(self, L):

#        if self.plantDelay > 0:
#
#            newList[0] = newList[0] + self.plantDelay
#            self.plantDelay = 0
#
#        if self.plantOption:
#            first_year = self.cuttingRange[0]-1
#            if L[first_year] > 0.4*self.max:
#                half = L[first_year]/2
#                L[first_year] = L[first_year] - half
#                newList[0] = newList[0] + half/2
#                self.plantDelay += half/2

        optCut = self.optimizeCut(L)
        toCut = [L[len(self.cuttingRange)-i-1]*optCut[i]
                 for i in range(len(self.cuttingRange))]
#        for i in range(len(toCut)):
#            toCut[i] = toCut[i] - toCut[i]%self.min_surface


        newList = L[1:]
        
        #print(L)
        #print(newList)
        newList.append(sum(toCut))
        for i in range(2*self.delta):
#            temp = L[self.cuttingRange[i] - 1]*(1-optCut[i])
#            newList[self.cuttingRange[i]
#                    ] = temp-temp%self.min_surface
            newList[i] = L[i+1]*(1-optCut[2*self.delta-1-i])
            
        return newList, toCut

    def optimizeCut(self, L):
            
        

        # cf  https://cvxopt.org/examples/tutorial/qp.html
        # et https://courses.csail.mit.edu/6.867/wiki/images/a/a7/Qp-cvxopt.pdf        
        data = L[1:self.delta*2+1][::-1]
        Q = np.zeros([self.delta*2,self.delta*2])  #Q correspond aux coefficients quadratiques
        P = np.zeros(self.delta*2)  #P correspond aux coefficients linéaires     
        
        nb_equation=4*self.delta+1
        G = []                      # G et H correspondent aux coefficients des contraintes 
        H = [0]*nb_equation

        
        for i in range(self.delta*2):
            
            Q[i][i]= 2*data[i]*data[i]
            
            if i == self.delta:
                P[i] = -2*self.mean*data[i]
                
            #bounds: valeurs entre 0 et 1
            G.append([0]*nb_equation)
            for j in range(nb_equation):
                if j==2*i:
                    G[i][j] = -1
                if j==2*i+1:
                    G[i][j] = 1
                    H[j] = 1
            #On ajoute la contrainte somme>=self.mean
            G[i][nb_equation-1] = -L[self.delta*2-i]
            
        H[nb_equation-1] = -self.mean+L[0]
        
        q=matrix(Q)
        p=matrix(P)
        g=matrix(G)
        h=matrix(H)




        solvers.options = {'refinement':2, 'abstol':0.01, 'reltol':0.01,'feastol':0.01 }
        sol=solvers.qp(q, p, g, h)
                
        if sol['x'] == None:   
        # cas où la condition somme(parametres)-moy>=0 ne peut pas être respecté
            result=[0,0,0,0]
        else:
            result=list(sol['x'])
            
        result.append(1)  #on coupe les arbres les plus vieux
             
        return(result)    
    

    def runSimulation(self):
        self.result = self.data[:]
        self.var = [np.var(self.data)]*len(self.data)
        
        newResult, toCut = self.moveElement(self.data)
        
        self.distrib_historic.append(np.flipud(toCut))
        if self.saveResults:
            self.saveResult(toCut, 0)
        self.var.append(np.var(newResult))
        self.result += [sum(toCut)]
        
        for i in range(1, self.simulationTime+1):

            newResult, toCut = self.moveElement(newResult)
            
            self.distrib_historic.append(np.flipud(toCut))
            if self.saveResults:
                self.saveResult(toCut, i)
            self.var.append(np.var(newResult))
            self.result += [sum(toCut)]
            print(i)

            
        self.distrib_historic = np.array(self.distrib_historic)
        self.roundValues()
        return
    
    def roundValues(self):
        # on arrondit les valeurs en sortie du modèle pour faciliter
        # le module de retour aux parcelles réelles
        def round_test(x, modulo):
            if x<modulo/2:
                return 0
            else :
                return modulo            
            
        for i in range(len(self.data), len(self.result)):
            self.result[i] = self.result[i]//self.min_surface * self.min_surface + round_test(self.result[i]%self.min_surface,self.min_surface)
        for i in range(len(self.distrib_historic)):
            for k in range(len(self.distrib_historic[0])):
                self.distrib_historic[i,k] = self.distrib_historic[i,k]//self.min_surface *self.min_surface + round_test(self.distrib_historic[i,k]%self.min_surface,self.min_surface)              

    def plotresult(self, name):
        self.years = [2021-len(self.data)+k for k in range(len(self.result))]
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        fig.add_trace(go.Bar(x=self.years, y=self.result,
                             marker_line_width=1.5, width=1, name="surface"))
        fig.add_trace(go.Scatter(x=self.years, y=self.var,
                                 mode='lines', name="variance"), secondary_y=True)

        fig.update_xaxes(title_text="Années")
        fig.update_yaxes(title_text="<b>Surface</b> ", secondary_y=False)
        fig.update_yaxes(title_text="<b>Variance</b> ", secondary_y=True)
        fig.update_layout(title='Model 3 with delta = +/- %s years, a minimal surface of %s and plantDelay = %s' %
                          (str(self.delta), str(self.min_surface), str(self.plantOption)))
        fig.write_html(name + ".html")

    def plot_distribution_surfaces(self, name):
        self.yearsDistrib = [2021+k for k in range(len(self.result))]
        fig = go.Figure()
        for i in range(self.distrib_historic.shape[1]):
            fig.add_trace(go.Bar(x=self.yearsDistrib, y=self.distrib_historic[:, i],
                                 marker_line_width=1.5, width=1, name='Age de coupe : '+str(self.age_cab+self.delta-i)))
        fig.update_layout(barmode='stack')
        fig.update_layout(title='Model 3 Distributions with delta = +/- %s years, a minimal surface of %s and plantDelay = %s' %
                          (str(self.delta), str(self.min_surface), str(self.plantOption)))
        fig.write_html(name + ".html")

    def saveResult(self, toCut, year):

        startingYear = str(2021 + year)
        if self.delta==2:
            text = "A l'année %s on coupe %s hectares en tout, il faut couper %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans et %s hectares de %s ans \n" % (
                    startingYear, np.sum(toCut), str(toCut[0]),str(self.age_cab-2),str(toCut[1]), str(self.age_cab-1),str(toCut[2]), str(self.age_cab),str(toCut[3]), str(self.age_cab+1),str(toCut[4]), str(self.age_cab+2))
            text = "%s %s %s %s %s \n" % (str(toCut[0]), str(
                   toCut[1]), str(toCut[2]), str(toCut[3]), str(toCut[4]))
            
        if self.delta==3:
            text = "A l'année %s on coupe %s hectares en tout, il faut couper %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans et %s hectares de %s ans \n" % (
                    startingYear, np.sum(toCut), str(toCut[0]),str(self.age_cab-3),str(toCut[1]),str(self.age_cab-2),str(toCut[2]), str(self.age_cab-1),str(toCut[3]), str(self.age_cab),str(toCut[4]), str(self.age_cab+1),str(toCut[5]), str(self.age_cab+2), str(toCut[6]),str(self.age_cab+3))
            text = "%s %s %s %s %s %s %s \n" % (str(toCut[0]), str(
                    toCut[1]), str(toCut[2]), str(toCut[3]), str(toCut[4]), str(toCut[5]), str(toCut[6]))
        
        if self.delta==4:
            text = "A l'année %s on coupe %s hectares en tout, il faut couper %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans et %s hectares de %s ans \n" % (
                    startingYear, np.sum(toCut), str(toCut[0]),str(self.age_cab-4),str(toCut[1]),str(self.age_cab-3),str(toCut[2]), str(self.age_cab-2),str(toCut[3]), str(self.age_cab-1),str(toCut[4]), str(self.age_cab),str(toCut[5]), str(self.age_cab+1), str(toCut[6]),str(self.age_cab+2),str(toCut[7]), str(self.age_cab+3), str(toCut[8]),str(self.age_cab+4))
            text = "%s %s %s %s %s %s %s %s %s \n" % (str(toCut[0]), str(
                    toCut[1]), str(toCut[2]), str(toCut[3]), str(toCut[4]), str(toCut[5]), str(toCut[6]), str(toCut[7]), str(toCut[8]))
        
        with open(self.savePath, "a") as f:

            f.write(text)
