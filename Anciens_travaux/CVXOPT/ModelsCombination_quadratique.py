from Model2 import Model2
from Model3_quadratique import Model3
from DataProcessing.DataProcessing import DataProcessing
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
import argparse
import json

"""
./Models/ModelsCombination.py [-h] [--forward_year FORWARD_YEAR]
                            [--model2-time MODEL2_TIME]
                            [--start_year START_YEAR] [--age_cab AGE_CAB]
                            [--model MODEL] [--delta DELTA]
                            [--min_surf MIN_SURF] [--max_iter MAX_ITER]
                            [--minimize_coupe_generation MINIMIZE_COUPE_GENERATION]
                            [--normalization NORMALIZATION]
                            [--data_preprocessing DATA_PREPROCESSING]

optional arguments:
  -h, --help            show this help message and exit
  --forward_year FORWARD_YEAR, -fy FORWARD_YEAR
                        modifie le nombre d'année sur lequel lancer
                        l'optimisation, par défaut 400 années
  --model2_time MODEL2_TIME, -mt MODEL2_TIME
                        modifie le nombre d'année sur lequel lancer
                        l'optimisation avec le modèle 2, par défaut 110 années
  --start_year START_YEAR, -sy START_YEAR
                        modifie l'année de départ du lancement de
                        l'optimisation, par défaut 2021
  --age_cab AGE_CAB, -ac AGE_CAB
                        modifie l'age de coupe à blanc, par défaut 52 années
  --model MODEL, -m MODEL
                        modifie le solveur du modèle (0 pour le recuit simulé,
                        1 pour la manière déterministe ou 2 pour l'algorithme
                        génétique), par défaut 0
  --delta DELTA, -d DELTA
                        modifie l'intervalle maximal de décalage de la coupe à
                        blanc, en année, par défaut 2 années
  --min_surf MIN_SURF, -ms MIN_SURF
                        modifie la surface minimale de coupe autorisé, en
                        hectare, par défaut 0.01 hectares
  --max_iter MAX_ITER, -iter MAX_ITER
                        modifie le nombre d'itérations maximal pour
                        l'algorithme de recuit simulé, par défaut 400000
  --minimize_coupe_generation MINIMIZE_COUPE_GENERATION, -mcg MINIMIZE_COUPE_GENERATION
                        Generation à partir de laquel limiter les décalages,
                        par défaut 5
  --normalization NORMALIZATION
                        modifie l'utilisation de la normalisation des données 
                        entre 0 et 1, vaut 1 pour l'utiliser, 0 pour non, par 
                        default  vaut 0
  --data_preprocessing DATA_PREPROCESSING
                        modifie la stratégie pour gérer les arbres anciens 
                        (avec un âge supérieur à âge_cab), voir plus bas pour 
                        le détail des stratégies, par default 'optimise2'
"""

default_forward_year = 400
default_model2_time = 110
default_start_year = 2021
default_age_cab = 52
default_model = 0
default_max_it = 2
default_min_surf = 0.01  # surface minimal de coupe
default_max_iter = 400000
default_minimize_coupe_generation = 5  # 3
default_normalization = 0
default_data_preprocessing = 'optimise2'

# Initiate the parser
parser = argparse.ArgumentParser()

# Add long and short argument
parser.add_argument("--forward_year", "-fy", default=default_forward_year,
                    help="modifie le nombre d'année sur lequel lancer l'optimisation, par défaut " + str(default_forward_year) + " années")
parser.add_argument("--model2_time", "-mt", default=default_model2_time,
                    help="modifie le nombre d'année sur lequel lancer l'optimisation avec le modèle 2, par défaut " + str(default_model2_time) + " années")
parser.add_argument("--start_year", "-sy",
                    default=default_start_year,
                    help="modifie l'année de départ du lancement de l'optimisation, par défaut " + str(default_start_year))
parser.add_argument("--age_cab", "-ac", default=default_age_cab,
                    help="modifie l'age de coupe à blanc, par défaut " + str(default_age_cab) + " années")
parser.add_argument(
    "--model", "-m", default=default_model,  help="modifie le solveur du modèle (0 pour le recuit simulé, 1 pour la manière déterministe ou 2 pour l'algorithme génétique), par défaut " + str(default_model))
parser.add_argument(
    "--max_it", "-it", default=default_max_it,  help="modifie l'intervalle maximal de décalage de la coupe à blanc, en année, par défaut " + str(default_max_it) + " années")
parser.add_argument("--min_surf", "-ms", default=default_min_surf,
                    help="modifie la surface minimale de coupe autorisé, en hectare, par défaut " + str(default_min_surf) + " hectares")
parser.add_argument("--max_iter", "-iter", default=default_max_iter,
                    help="modifie le nombre d'itérations maximal pour l'algorithme de recuit simulé, par défaut " + str(default_max_iter))
parser.add_argument("--minimize_coupe_generation", "-mcg", default=default_minimize_coupe_generation,
                    help="Generation à partir de laquel limiter les décalages, par défaut " + str(default_minimize_coupe_generation))
parser.add_argument("--normalization", default=default_normalization,
                    help="normalisation des données entre 0 et 1")
parser.add_argument("--data_preprocessing", default=default_data_preprocessing,
                    type=str, help="Traitement sur les données d'entrée")
# Read arguments from the command line
args = parser.parse_args()


print(args)

forward_year = int(args.forward_year)
model2_time = int(args.model2_time)
start_year = int(args.start_year)
age_cab = int(args.age_cab)
model = int(args.model)
max_it = int(args.max_it)
min_surf = float(args.min_surf)
max_iter = int(args.max_iter)
minimize_coupe_generation = int(args.minimize_coupe_generation)
normalization = int(args.normalization)



type_model = ["Model2-RecuitSimule",
              "Model2-Deterministe", "Model2-Genetic"][model]


optimization_surfaces = []
optimization_distrib = []



# on récupère les données
dataProcessing = DataProcessing(age_cab, max_it, "./Data/simu.json")


# traitement des arbres anciens 
if args.data_preprocessing == None :
    data = dataProcessing.parcelles_cpt

if args.data_preprocessing == 'pic':   
    data = dataProcessing.parcelles_ancien_pic()
    
if args.data_preprocessing == 'optimise1':
        
    # stratégie d'optimisation initiale numéro 1: on remplit les 'trous'
    # (valeur de l'année<moy) avec les arbres anciens, et tant qu'on n'a pas dépassé la moyenne
    #Une fois qu'on a dépassé la moyenne, on avance jusqu'au prochain trou
    # On ne se fixe pas d'année de décalage maximum.
        
    data = dataProcessing.parcelles_ancien_optimise1()        

        
if args.data_preprocessing == 'optimise2':        
    # stratégie d'optimisation initiale numéro 2: on cherche l'année de valeur minimale 
    # dans la portée de limit_decal, et on y ajoute la parcelle la plus grande.
    # On recommence l'opération jusqu'à ce qu'on ait placé tous les arbres anciens
        
        
    limit_decal= 10  #limit_decal correspond au nombre d'années max 
    #pour le retard des vieux arbres dans la stratégie d'optimisation initiale 

       
    data= dataProcessing.parcelles_ancien_optimise2(limit_decal)
        
# normalisation des données
if normalization == True :
        
    max_data = max(data)
      
    for i in range(len(data)):        
        data[i] = data[i]/max_data 

print(data)      
model2 = Model2(data, dataProcessing.years[-age_cab:], type_model, forward_year=model2_time, age_cab=age_cab, max_it=max_it, min_surf=min_surf, max_iter=max_iter, minimize_coupe_generation=minimize_coupe_generation, save_results=False)


model2.optimize()

optimization_surfaces += model2.modif_surfaces
optimization_distrib += list(model2.distrib_historic)

historic_decoupe = {}
for i in range(model2.distrib_historic.shape[0]):
    historic_decoupe[model2.years[i] +
                     age_cab] = list(model2.distrib_historic[i])

#calcul de la moyenne des données d'entrée
mean_entree=np.mean(data)
model_combination=1

model = Model3(model2.modif_surfaces[-(age_cab+max_it):],
               forward_year-len(model2.modif_surfaces)+age_cab, delta=max_it, min_surface=min_surf, saveResults=False, model_combination=model_combination, mean_entree=mean_entree)
model.runSimulation()
optimization_surfaces += model.result[age_cab+max_it:]
optimization_distrib += list(model.distrib_historic)

for i in range(model.distrib_historic.shape[0]):
    historic_decoupe[model2.years[-1]+age_cab +
                     i+1] = list(model.distrib_historic[i])
   

print(optimization_surfaces)
# si on a normalisé, on retourne aux ordres de grandeur initiaux
if normalization == True :
          
    for i in range(len(optimization_surfaces)):        
        optimization_surfaces[i] = optimization_surfaces[i]*max_data
          
    for i in range(len(optimization_distrib)):
        for j in range (max_it*2+1):
            
            optimization_distrib[i][j] = optimization_distrib[i][j]*max_data
            

def plot_surfaces(years, modelData, age_cab, name="CVXOPT/resultats/ModelsCombination/modelsCombination"):
    fig = make_subplots(specs=[[{"secondary_y": True}]])
    fig.add_trace(go.Bar(x=years, y=modelData,
                         marker_line_width=1.5, width=1, name="Distrib ModelsCombination"))
    fig.add_trace(go.Scatter(x=years[:len(years)-age_cab], y=[np.var(
        modelData[k:k+age_cab]) for k in range(len(modelData)-age_cab)], mode='lines', name="Variance ModelsCombination"), secondary_y=True)

    fig.update_xaxes(title_text="Années")
    fig.update_yaxes(title_text="<b>Surface</b> ", secondary_y=False)
    fig.update_yaxes(title_text="<b>Variance</b> ", secondary_y=True)
    fig.update_layout(title='Model combination with delta = +/- %s years, a minimal surface of %s' %
                          (str(max_it), str(min_surf)))

    fig.write_html(name + ".html")

    return


def plot_distribution_surfaces(years, distrib_historic, age_cab, max_it, name="CVXOPT/resultats/ModelsCombination/modelsCombination-distrib"):
    fig = go.Figure()
    for i in range(distrib_historic.shape[1]):
        fig.add_trace(go.Bar(x=years[age_cab:], y=distrib_historic[:, i],
                             marker_line_width=1.5, width=1, name='Age de coupe : '+str(age_cab+max_it-i)))
    fig.update_layout(barmode='stack')
    fig.update_layout(title='Model combination distribution with delta = +/- %s years, a minimal surface of %s' %
                         (str(max_it), str(min_surf)))
    fig.write_html(name + ".html")
    return


plot_surfaces([str(k+start_year-age_cab)
               for k in range(len(optimization_surfaces))], optimization_surfaces, age_cab)

print("Graphique des distributions et variance enregistré dans le fichier " +
      "CVXOPT/resultats/ModelsCombination/modelsCombination.html")

plot_distribution_surfaces([str(k+start_year-age_cab)
                            for k in range(len(optimization_distrib))], optimization_distrib, age_cab, max_it)

print("Graphique des distributions et décalages enregistré dans le fichier " +
      "CVXOPT/resultats/ModelsCombination/modelsCombination-distrib.html")

#with open("CVXOPT/resultats/ModelComparison/ModelsCombination-Result.txt", "w") as txtfile:
#    txtfile.write(",".join([str(elt) for elt in optimization_surfaces]))
#
#print("Distribution des surfaces enregistrées dans le fichier " +
#      "Result/ModelComparison/ModelsCombination-Result.txt")


#with open("CVXOPT/resultats/HistoricDecoupe/ModelsCombination-Result.json", "w") as json_file:
#    json.dump(historic_decoupe, json_file)
#
#print("Historique des découpes enregistrés dans le fichier " +
#      "CVXOPT/resultats/HistoricDecoupe/ModelsCombination-Result.json")

#plan_de_coupe = "\n".join([" ".join([str(nb) for nb in elt])
#                           for elt in list(historic_decoupe.values())])
#with open("CVXOPT/resultats/PlanDeCoupe/ModelsCombination-Result.txt", "w") as f:
#    f.write(plan_de_coupe)
#
#print("Plan de coupe enregistré dans le fichier " +
#      "CVXOPT/resultats/PlanDeCoupe/ModelsCombination-Result.txt")
