import numpy as np
import os
from scipy.optimize import minimize
import plotly.graph_objects as go
from plotly.subplots import make_subplots


class Model3():

    def __init__(self, data, simulationTime, delta=2, age_cab=52, plantOption=False, min_surface=0.1, saveResults=True, model_combination=0, mean_entree=0):

        self.data = data
        self.simulationTime = simulationTime
        self.plantOption = plantOption
        if model_combination == 0:
            self.mean = np.mean(self.data)   # on utilise le modèle 3 seul
        else:
            self.mean = mean_entree        # on utilise le modèle 3 dans le modèle combination
        self.max = np.max(self.data)
        self.delta = delta
        self.age_cab=age_cab
        self.min_surface = min_surface
        self.saveResults = saveResults
        self.savePath = "Result/PlanDeCoupe/Model3.txt"
        self.cuttingRange = list(range(self.age_cab-self.delta, self.age_cab+self.delta+1))
        self.plantDelay = 0

        if self.saveResults and os.path.exists(self.savePath):
            os.remove(self.savePath)
        self.result = []
        self.distrib_historic = []

    def moveElement(self, L):

#        if self.plantDelay > 0:
#
#            newList[0] = newList[0] + self.plantDelay
#            self.plantDelay = 0
#
#        if self.plantOption:
#            first_year = self.cuttingRange[0]-1
#            if L[first_year] > 0.4*self.max:
#                half = L[first_year]/2
#                L[first_year] = L[first_year] - half
#                newList[0] = newList[0] + half/2
#                self.plantDelay += half/2

        optCut = self.optimizeCut(L)
        toCut = [L[len(self.cuttingRange)-i-1]*optCut[i]
                 for i in range(len(self.cuttingRange))]
#        for i in range(len(toCut)):
#            toCut[i] = toCut[i] - toCut[i]%self.min_surface


        newList = L[1:]
        
        #print(L)
        #print(newList)
        newList.append(sum(toCut))
        for i in range(2*self.delta):
#            temp = L[self.cuttingRange[i] - 1]*(1-optCut[i])
#            newList[self.cuttingRange[i]
#                    ] = temp-temp%self.min_surface
            newList[i] = L[i+1]*(1-optCut[2*self.delta-1-i])
        print(L)    
        return newList, toCut

    def optimizeCut(self, L):
        
        def f(x):

            parameters = [L[len(self.cuttingRange)-i-1]*x[i]
                          for i in range(len(self.cuttingRange))]
            return sum(parameters) - self.mean

#        def f(x):
#
#            parameters = np.array([L[len(self.cuttingRange)-i-1]*x[i]
#                          for i in range(len(self.cuttingRange))])
#
#            target = np.array([0] * len(self.cuttingRange))
#            target[len(self.cuttingRange)//2] = self.mean
#            
#            r = list(np.sqrt((parameters-target)*(parameters-target)))
#
#            return sum(r)
            
        cons = []
#        def g(x):
#            return(L[self.cuttingRange[i]-1]*x[i] - self.min_surface/2)^2-(self.min_surface/2)^2        
#        x=0 or x>= alpha
#        x-alpha/2=-alpha/2 or x-alpha/2>=alpha/2
#        [(x-alpha/2)^2=(-alpha/2)^2 or (x-alpha/2)^2>=(alpha/2)^2] and alpha/2>0
#        (x-alpha/2)^2-(alpha/2)^2>=0
        
        
#        for i in range(len(self.cuttingRange)-1):
#            
#            min_surface_con = {"type" : "ineq", "fun" : lambda x: g(x)}
#            cons.append(min_surface_con)
        
        
        #Problème pour implémenter la notion de surface minimum: xor non supporté par minimize

        cons.append(
            {'type': 'eq', 'fun': lambda x:  x[len(self.cuttingRange)-1] - 1})
        cons.append({'type': 'ineq', 'fun': lambda x:  f(x)-0})

        bounds = [(0, 1)]*len(self.cuttingRange)
        init = np.zeros((1, len(self.cuttingRange)))
        init[0, -1] = 1
        res = minimize(f, init,
                       method='SLSQP', bounds=bounds, constraints=cons)
        return res.x

    def runSimulation(self):
        self.result = self.data[:]
        self.var = [np.var(self.data)]*len(self.data)
        
        newResult, toCut = self.moveElement(self.data)
        
        self.distrib_historic.append(np.flipud(toCut))
        if self.saveResults:
            self.saveResult(toCut, 0)
        self.var.append(np.var(newResult))
        self.result += [sum(toCut)]
        
        for i in range(1, self.simulationTime+1):

            newResult, toCut = self.moveElement(newResult)
            
            self.distrib_historic.append(np.flipud(toCut))
            if self.saveResults:
                self.saveResult(toCut, i)
            self.var.append(np.var(newResult))
            self.result += [sum(toCut)]
#            if i % len(self.data) == 0:      c'est n'importe quoi
#                self.result += newResult
            
        self.distrib_historic = np.array(self.distrib_historic)
#        self.roundValues()
        return
    
    def roundValues(self):
        def round_test(x, modulo):
            if x<modulo/2:
                return 0
            else :
                return modulo            
            
        for i in range(len(self.data), len(self.result)):
            self.result[i] = self.result[i]//self.min_surface * self.min_surface + round_test(self.result[i]%self.min_surface,self.min_surface)
        for i in range(len(self.distrib_historic)):
            for k in range(len(self.distrib_historic[0])):
                self.distrib_historic[i,k] = self.distrib_historic[i,k]//self.min_surface *self.min_surface + round_test(self.distrib_historic[i,k]%self.min_surface,self.min_surface)              

    def plotresult(self, name):
        self.years = [2021-len(self.data)+k for k in range(len(self.result))]
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        fig.add_trace(go.Bar(x=self.years, y=self.result,
                             marker_line_width=1.5, width=1, name="surface"))
        fig.add_trace(go.Scatter(x=self.years, y=self.var,
                                 mode='lines', name="variance"), secondary_y=True)

        fig.update_xaxes(title_text="Années")
        fig.update_yaxes(title_text="<b>Surface</b> ", secondary_y=False)
        fig.update_yaxes(title_text="<b>Variance</b> ", secondary_y=True)
        fig.update_layout(title='Model 3 with delta = +/- %s years, a minimal surface of %s and plantDelay = %s' %
                          (str(self.delta), str(self.min_surface), str(self.plantOption)))
        fig.write_html(name + ".html")

    def plot_distribution_surfaces(self, name):
        self.yearsDistrib = [2021+k for k in range(len(self.result))]
        fig = go.Figure()
        for i in range(self.distrib_historic.shape[1]):
            fig.add_trace(go.Bar(x=self.yearsDistrib, y=self.distrib_historic[:, i],
                                 marker_line_width=1.5, width=1, name='Age de coupe : '+str(self.age_cab+self.delta-i)))
        fig.update_layout(barmode='stack')
        fig.update_layout(title='Model 3 Distributions with delta = +/- %s years, a minimal surface of %s and plantDelay = %s' %
                          (str(self.delta), str(self.min_surface), str(self.plantOption)))
        fig.write_html(name + ".html")

    def saveResult(self, toCut, year):

        startingYear = str(2021 + year)
        if self.delta==2:
            text = "A l'année %s on coupe %s hectares en tout, il faut couper %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans et %s hectares de %s ans \n" % (
                    startingYear, np.sum(toCut), str(toCut[0]),str(self.age_cab-2),str(toCut[1]), str(self.age_cab-1),str(toCut[2]), str(self.age_cab),str(toCut[3]), str(self.age_cab+1),str(toCut[4]), str(self.age_cab+2))
            text = "%s %s %s %s %s \n" % (str(toCut[0]), str(
                   toCut[1]), str(toCut[2]), str(toCut[3]), str(toCut[4]))
            
        if self.delta==3:
            text = "A l'année %s on coupe %s hectares en tout, il faut couper %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans et %s hectares de %s ans \n" % (
                    startingYear, np.sum(toCut), str(toCut[0]),str(self.age_cab-3),str(toCut[1]),str(self.age_cab-2),str(toCut[2]), str(self.age_cab-1),str(toCut[3]), str(self.age_cab),str(toCut[4]), str(self.age_cab+1),str(toCut[5]), str(self.age_cab+2), str(toCut[6]),str(self.age_cab+3))
            text = "%s %s %s %s %s %s %s \n" % (str(toCut[0]), str(
                    toCut[1]), str(toCut[2]), str(toCut[3]), str(toCut[4]), str(toCut[5]), str(toCut[6]))
        
        if self.delta==4:
            text = "A l'année %s on coupe %s hectares en tout, il faut couper %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans, %s hectares de %s ans et %s hectares de %s ans \n" % (
                    startingYear, np.sum(toCut), str(toCut[0]),str(self.age_cab-4),str(toCut[1]),str(self.age_cab-3),str(toCut[2]), str(self.age_cab-2),str(toCut[3]), str(self.age_cab-1),str(toCut[4]), str(self.age_cab),str(toCut[5]), str(self.age_cab+1), str(toCut[6]),str(self.age_cab+2),str(toCut[7]), str(self.age_cab+3), str(toCut[8]),str(self.age_cab+4))
            text = "%s %s %s %s %s %s %s %s %s \n" % (str(toCut[0]), str(
                    toCut[1]), str(toCut[2]), str(toCut[3]), str(toCut[4]), str(toCut[5]), str(toCut[6]), str(toCut[7]), str(toCut[8]))
        
        with open(self.savePath, "a") as f:

            f.write(text)
