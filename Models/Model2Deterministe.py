from scipy.optimize import minimize
import numpy as np


class Model2Deterministe:
    def __init__(self, modif_surfaces, max_it=2):
        self.max_it = max_it
        self.len_gen = len(modif_surfaces)
        self.modif_surfaces = modif_surfaces
        self.X = np.zeros((self.len_gen, self.len_gen+4))
        for j in range(self.len_gen):
            self.X[j][j+2] = self.modif_surfaces[j]

    def objective(self, X):
        if X.shape == (self.len_gen * (2*self.max_it+1),):
            X = self.toX(X)
            X = self.partial_matrix_to_full_matrix(X)
        # return np.sum(np.sum(X[:, self.max_it: self.len_gen+self.max_it], axis=0) - np.mean(np.sum(X[:, self.max_it: self.len_gen+self.max_it], axis=0)))
        return np.var(np.sum(X[:, self.max_it: self.len_gen+self.max_it], axis=0))

    def full_matrix_to_partial_matrix(self, X):
        partialX = np.zeros((self.len_gen, 2*self.max_it+1))
        for i in range(self.len_gen):
            partialX[i] = X[i][i:i+2*self.max_it+1]
        return partialX

    def partial_matrix_to_full_matrix(self, partialX):
        X = np.zeros((self.len_gen, self.len_gen+2*self.max_it))
        for i in range(self.len_gen):
            X[i][i:i+2*self.max_it+1] = partialX[i]
        return X

    def toVector(self, X):
        assert X.shape == (self.len_gen, 2*self.max_it+1)
        return np.hstack([X.flatten()])

    def toX(self, vec):
        assert vec.shape == (self.len_gen * (2*self.max_it+1),)
        return vec.reshape(self.len_gen, 2*self.max_it+1)

    def optimize(self):

        # show initial objective
        initial_loss = self.objective(self.X)
        print('Initial SSE Objective: ' +
              str(initial_loss))
        XtoOpt = self.full_matrix_to_partial_matrix(self.X)
        XtoOpt = self.toVector(XtoOpt)
        # optimize
        b = (0.0, np.max(self.modif_surfaces[0:self.len_gen]))
        bnds = [b for k in range(XtoOpt.shape[0])]

        list_constr = []

        print("self.modif_surfaces : ", self.modif_surfaces)
        epsilon = 1e-3
        # les quantités d'abres à couper 2 ans avant le début de la génération ou après la fin de la génération
        # ne peuvent être non nulles

        list_constr.append({'type': 'eq', 'fun': lambda x: x[0]})
        list_constr.append({'type': 'eq', 'fun': lambda x: x[1]})
        list_constr.append({'type': 'eq', 'fun': lambda x: x[self.max_it*2+1]})
        list_constr.append(
            {'type': 'eq', 'fun': lambda x: x[(self.max_it*2+1)*(self.len_gen-1)-1]})
        list_constr.append(
            {'type': 'eq', 'fun': lambda x: x[(self.max_it*2+1)*self.len_gen-2]})
        list_constr.append(
            {'type': 'eq', 'fun': lambda x: x[(self.max_it*2+1)*self.len_gen-1]})

        for i in range(self.len_gen):
            # la somme des arbres à couper d'âge normal i (étalable sur +- 2 ans) doit être égale à la quantité disponible
            # list_constr.append({'type': 'eq', 'fun': lambda x: np.sum(
            #     [x[i*(1+2*self.max_it) + j] for j in range(1+2*self.max_it)]) - self.modif_surfaces[i]})
            list_constr.append({'type': 'ineq', 'fun': lambda x: np.sum(
                [x[i*(1+2*self.max_it) + j] for j in range(1+2*self.max_it)]) - self.modif_surfaces[i]+epsilon})
            list_constr.append({'type': 'ineq', 'fun': lambda x: -np.sum(
                [x[i*(1+2*self.max_it) + j] for j in range(1+2*self.max_it)]) + self.modif_surfaces[i]+epsilon})

        cons = tuple(list_constr)

        print("Nombre de contraintes : ", len(list_constr))

        res = minimize(self.objective,
                       XtoOpt,
                       method='SLSQP',
                       bounds=bnds,
                       constraints=cons,
                       options={'maxiter': 100,  'disp': True, 'ftol': 1},
                       # 'ftol': int(initial_loss)},
                       #    tol=int(initial_loss))
                       )

        newX = res.x
        print('Final SSE Objective: ' + str(self.objective(newX)))

        newX = self.toX(newX)
        print(np.sum(newX, axis=1))
        print(np.round(newX, 2))
        newX = self.partial_matrix_to_full_matrix(newX)

        # print solution
        print('Solution')
        print('newX :', np.round(newX, 4))

        return newX
