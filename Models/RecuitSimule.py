import numpy as np
import random


class RecuitSimule:
    def __init__(self, X0, generation, max_iter=10000, max_it=2, minimize_coupe=False,  min_surf=0.1):
        self.X0 = X0
        self.X = X0.copy()
        self.Xg = X0.copy()
        self.T0 = 100
        self.T = self.T0
        self.Tmin = 1e-4
        self.tau = 1e4
        self.time = 0
        self.generation = generation
        self.max_iter = max_iter
        self.max_it = max_it
        self.min_surf = min_surf
        self.minimize_coupe = minimize_coupe
        self.EX = self.energie_totale(self.X)
        self.EXg = self.energie_totale(self.Xg)

    def partial_energie(self, X):
        Xtranspose = np.concatenate((np.zeros((X.shape[0], self.max_it)), np.transpose(
            X[:, self.max_it: X.shape[0]+self.max_it]), np.zeros((X.shape[0], self.max_it))), axis=1)
        XtransposeClean = np.array(
            [Xtranspose[i, i:i+2*self.max_it+1] for i in range(self.X.shape[0])])

        worse_vector = np.array(
            [np.sum(XtransposeClean)/(2*self.max_it) for k in range(2*self.max_it+1)])
        worse_vector[self.max_it] = 0
        var_max = np.var(worse_vector)
        # variance de la différence entre distribution sur les 5 années et la pire distribution sur les 5 années
        return np.var(np.sum(XtransposeClean, axis=0)-np.concatenate((np.zeros((self.max_it, )),
                                                                      np.array([np.sum(XtransposeClean)]), np.zeros((self.max_it, )))))/var_max

    def energie_totale(self, X):
        variance_newX = np.var(
            np.sum(X[:, self.max_it:X.shape[1]+self.max_it], axis=0))
        if not self.minimize_coupe:
            return variance_newX
        else:
            # minimisation de la nouvelle distribution et minimisation des vecteurs
            # print(variance_newX, self.partial_energie(X))
            # 1*(self.generation+1)*
            # **2
            return variance_newX + self.partial_energie(X)/((self.generation+1))

    def generate_distrib(self, value_sum, length=5):
        distrib = [random.uniform(0, 1)]
        for i in range(1, length-1):
            srf_aleatoire = random.uniform(0, 1-sum(distrib[:i]))
            if (srf_aleatoire > self.min_surf):
                distrib.append(srf_aleatoire)
            else:
                distrib.append(0)
        if 1-sum(distrib) < self.min_surf:
            # if distrib[self.max_it] != 0:
            #     distrib[self.max_it] += 1-sum(distrib)
            # else:
            for j in range(len(distrib)):
                if distrib[j] != 0:
                    distrib[j] += 1-sum(distrib)
                    break
            if sum(distrib) == 0:
                distrib.append(1-sum(distrib))
            else:
                distrib.append(0)
        else:
            distrib.append(1-sum(distrib))
        random.shuffle(distrib)
        return value_sum*np.array(distrib)

    def fluctuation(self):
        # faire varier les coefficients qui ont le droit de varier en respectant bien les contraintes de somme et de nulité
        X = self.X.copy()
        i = random.randint(0, self.X.shape[0]-1)

        if i < self.max_it:
            X[i, self.max_it:i +
              2*self.max_it+1] = self.generate_distrib(np.sum(self.X0[i]), 2*self.max_it+1-self.max_it+i)
        elif i > X.shape[0]-self.max_it:
            X[i, i:X.shape[0] +
                self.max_it] = self.generate_distrib(np.sum(self.X0[i]), 2*self.max_it+1-self.max_it+(-i+X.shape[0]-1))
        else:
            X[i, i:i +
                2*self.max_it+1] = self.generate_distrib(np.sum(self.X0[i]), 2*self.max_it+1)

        return X

    def refroidissement(self):
        self.T = self.T0*np.exp(-self.time/self.tau)

    def optimize(self):
        while self.T > self.Tmin and self.time < self.max_iter:

            X = self.fluctuation()
            EX = self.energie_totale(X)
            # print(self.time, EX, self.T)

            if EX < self.EX or random.uniform(0, 1) < np.exp(-(EX-self.EX)/self.T):
                self.X = X
                self.EX = EX
                if self.EX < self.EXg:
                    self.Xg = self.X
                    self.EXg = self.EX
            self.time += 1
            self.refroidissement()
        return self.Xg
